/**********************************************************************************************************************************************************
*
*    \ |   __|  _ \    \ __ __|  \    |    _ _|   \ |  |  /  __|  _ \
*   .  |  (_ |  |  |  _ \   |   _ \   |      |   .  |  . <   _|     /
*  _|\_| \___| ___/ _/  _\ _| _/  _\ ____| ___| _|\_| _|\_\ ___| _|_\
*
**********************************************************************************************************************************************************
*
*	Last Revision : Rev 1.0 11/02/2021
*
*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
* 
*   Rev 1.0 11/02/2021
*		Started.
*		OzzyOuzo.
*		
*-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
*
* NGDataLinker is a tool which generates consistent addresses needed during link for data accessed through bank switching mecanism on P roms.
*
* Contact:
*	Author:sundayozzy@gmail.com
*
***********************************************************************************************************************************************************/
#include <stdio.h>
#include <conio.h>
#include <string.h>
#include <stdlib.h>
#include <inttypes.h>
#include <vector>

#define MAX_LINE_LENGTH			1024

char* cutAndPut(char* filename, const char* extension)
{
	uint32_t i = 0, j = 0;
	int32_t len;
	char buf[MAX_LINE_LENGTH], *pbuf = buf, *pname;

	if (filename == NULL || extension == NULL || (!strlen(filename))) return filename;
	if (strlen(filename) + strlen(extension) >= MAX_LINE_LENGTH) return filename;

	len = strlen(filename) - 1;
	pname = filename + len;

	while (len-- && *pname != '.' && *pname != '/' && *pname != '\\')
		pname--;
	if (len < 0) {
		len = strlen(filename);
	}
	else {
		len++;

		if (*pname == '/' || *pname == '\\')
			len = strlen(filename);
	}

	strncpy(buf, filename, len);
	pbuf += len;

	while (*extension == '.') extension++;
	*pbuf++ = '.';

	while (*extension != 0) *pbuf++ = *extension++;

	*pbuf++ = 0;

	sprintf_s(filename, MAX_LINE_LENGTH, "%s", buf);

	return (filename);
}

const char *cleanString(const char* string_)
{
	int32_t i, j, len;
	static char cleaned[MAX_LINE_LENGTH];

	if (string_ == nullptr) {
		return nullptr;
	}

	memset(cleaned, 0, MAX_LINE_LENGTH);

	len = strlen(string_);
	j = 0;
	for (i = 0; i < len; i++) {
		if (string_[i] != 0x20 && string_[i] != '\t' && string_[i] != '\n') {
			cleaned[j++] = string_[i];
		}
	}

	return cleaned;
}
char* kickExtension(char* filename)
{
	char* pName;
	int32_t len;

	if (filename == NULL) return filename;
	if (strchr(filename, '.') == NULL) return filename;

	len = strlen(filename) - 1;
	pName = filename;

	while (pName[len] != '.') {
		len--;
	}

	filename[len] = 0;

	return filename;
}
char* kickPath(char* filename)
{
	char* pName;

	if (filename == NULL) return filename;
	pName = strrchr(filename, '/');
	if (pName == NULL) {
		pName = strrchr(filename, '\\');
		if (pName != NULL) {
			return pName + 1;
		}
	}
	else {
		return pName + 1;
	}
	return filename;
}

char *hasNotDoubleOffset(char *string_)
{
	char *ptr;

	if ((ptr = strstr(string_,"0x")) == nullptr){
		return nullptr;
	}
	if (strstr(ptr+2,"0x")){
		return nullptr;
	}
	return ptr;
}
char *getDep(char *string_)
{
	char *ptr;

	ptr = strchr(string_,0x20);
	return ptr;
}
int main(int argc, char *argv[])
{
	uint32_t i;
	FILE *fp, *fp2;
	bool error = false;
	char outDir[MAX_LINE_LENGTH];
	char filename[MAX_LINE_LENGTH];
	char nameUp[MAX_LINE_LENGTH];
	char filemap[MAX_LINE_LENGTH];
	char string[MAX_LINE_LENGTH];
	char *ptr,*pString;
	std::vector<std::string> _modules;
	std::string module;


	if (argc <= 1) {
		fprintf(stderr, "\nUsage: ngDataLinker <GCC map file> <out directory>\n");
		return 1;
	}

	strcpy(filename, argv[1]);
	strcpy(filemap, filename);
	strcpy(nameUp, kickPath(kickExtension(filename)));
	strcat(nameUp,"_h");
	cutAndPut(filename,".h");

	strcpy(outDir, argv[2]);


	_strupr(nameUp);

	strcat(outDir,kickPath(filename));
	fp2 = fopen(outDir,"wt");
	if (fp2 == NULL){
		printf("\ncan't create output file : %s\n", filename);
		return 1;
	}

	fprintf(fp2, "#ifndef _%s_\n", nameUp);
	fprintf(fp2, "#define _%s_\n", nameUp);

	fprintf(fp2, "\n//\n//Generated by ngDataLinker 1.0 coded by Ozzy \n//\n\n\n");

	fp = fopen(filemap, "rt");
	if (fp == NULL) {
		printf("\nfile not found %s\n", argv[1]);
		return 1;
	}

	while ((!feof(fp)) && (!error)) {
		fgets(string, MAX_LINE_LENGTH, fp);

		if ((ptr=strstr(string,"LOAD ")) != nullptr){
			module = cleanString(ptr+5);
			_modules.push_back(module);
		}
		else{
			for (i=0; i < _modules.size();i++){
				if (strstr(string,_modules[i].c_str()) != nullptr){

					fgets(string, MAX_LINE_LENGTH, fp);

					while ((ptr = hasNotDoubleOffset(string)) != nullptr) {
						pString = getDep(ptr);
						fprintf(fp2, "\n#define %s \t\t0x%08x", cleanString(pString + 1), (strtoul(ptr, NULL, 0) + 0x200000));
						fgets(string, MAX_LINE_LENGTH, fp);
					}
				}
			}
		}
	}

	fclose(fp);
	fprintf(fp2, "\n\n#endif //_%s_\n\n", nameUp);
	fclose(fp2);

	return 0;
}
